// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'
// Upgrade NOTE: replaced '_World2Object' with 'unity_WorldToObject'

Shader "Unlit/CloudShader"
{
	Properties
	{
		_Color("Color", Color) = (1,1,1,1)
		_MainTex ("Texture", 2D) = "white" {}
	    _FogHeight("FogHeight", float) = 10.0
		_FogFactor("FogFactor", float) = 10.0
		_FogNoiseHeight("FogNoiseHeight", float) = 10.0
	    _FogNoiseScale("FogNoiseScale", float) = 1.0
		_FogNoiseSpeed("FogNoiseSpeed", float) = 0.1
		_FogNoiseScale("FogNoiseScale", float) = 1.0
		_FogLight1Pos("FogLight1Pos", Vector) = (0.0, 0.0, 0.0)
		_FogLight1Color("FogLight1Color", Color) = (1,1,1,1)
		_FogLight1Factor("FogLight1Factor", float) = 600.0
		_FogLight2Pos("FogLight2Pos", Vector) = (0.0, 0.0, 0.0)
		_FogLight2Color("FogLight2Color", Color) = (1,1,1,1)
		_FogLight2Factor("FogLight2Factor", float) = 600.0
	}
	SubShader
	{
		Tags{ "RenderType" = "Transparent" }
		LOD 100
		//Cull Off
		ZWrite Off
		Blend One SrcAlpha

		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			
			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
				float2 uv : TEXCOORD0;
			};

			struct v2f
			{
				float2 uv : TEXCOORD0;
				float4 vertex : SV_POSITION;
				float3 worldPos : TEXCOORD1;
				//float4 screenCoord : TEXCOORD2;
			};

			sampler2D _MainTex;
			float4 _MainTex_ST;
			float4 _Color;
			float  _FogHeight;
			float  _FogFactor;
			float  _FogNoiseHeight;
			float  _FogNoiseScale;
			float  _FogNoiseSpeed;
			float3 _FogLight1Pos;
			float4 _FogLight1Color;
			float  _FogLight1Factor;
			float3 _FogLight2Pos;
			float4 _FogLight2Color;
			float  _FogLight2Factor;


			v2f vert (appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
				o.uv = TRANSFORM_TEX(v.uv, _MainTex);
				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
				//o.screenCoord = ComputeScreenPos(o.vertex);
				return o;
			}
// glsl -> hlsl cheatsheet:
// vec -> float
// mat? -> float?x?
// mix -> lerp
// fract -> frac
// mod -> fmod
// atan -> atan2
// M * v -> mul(M,v)
// Texture2D -> Tex2D

////// FROM https://www.shadertoy.com/view/XlBSRz by SebH //////

// Apply noise on top of the height fog?
#define D_FOG_NOISE 1.0

// Enable/disable volumetric shadow (single scattering shadow)
#define D_VOLUME_SHADOW_ENABLE 1

// Use imporved scattering?
// In this mode it is full screen and can be toggle on/off.
#define D_USE_IMPROVE_INTEGRATION 1

// Used to control wether transmittance is updated before or after scattering (when not using improved integration)
// If 0 strongly scattering participating media will not be energy conservative
// If 1 participating media will look too dark especially for strong extinction (as compared to what it should be)
// Toggle only visible when not using the improved scattering integration.
#define D_UPDATE_TRANS_FIRST 0

// Use to restrict ray marching length. Needed for volumetric evaluation.
#define D_MAX_STEP_LENGTH_ENABLE 1

// Light position and color
//#define LPOS float3( 20.0+15.0*sin(_Time.y), 15.0+12.0*cos(_Time.y),-20.0)

			/*
float displacementSimple( float2 p )
{
    float f;
    f  = 0.5000* tex2D(_MainTex,p).x; p = p*2.0;
	f += 0.2500* tex2D(_MainTex,p).x; p = p*2.0;
	f += 0.1250* tex2D(_MainTex,p).x; p = p*2.0;
	f += 0.0625* tex2D(_MainTex,p).x; p = p*2.0;
    
    return f;
}
*/
			
// Noise, as generated by https://github.com/keijiro/NoiseShader
void FAST32_hash_2D(float2 gridcell, out float4 hash_0, out float4 hash_1)
{
	const float2 OFFSET = float2(26.0, 161.0);
	const float DOMAIN = 71.0;
	const float2 SOMELARGEFLOATS = float2(951.135664, 642.949883);
	float4 P = float4(gridcell.xy, gridcell.xy + 1.0);
	P = P - floor(P * (1.0 / DOMAIN)) * DOMAIN;
	P += OFFSET.xyxy;
	P *= P;
	P = P.xzxz * P.yyww;
	hash_0 = frac(P * (1.0 / SOMELARGEFLOATS.x));
	hash_1 = frac(P * (1.0 / SOMELARGEFLOATS.y));
}
float2 Interpolation_C2(float2 x) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }
float Perlin2D(float2 P)
{
	//	establish our grid cell and unit position
	float2 Pi = floor(P);
	float4 Pf_Pfmin1 = P.xyxy - float4(Pi, Pi + 1.0);

	//	calculate the hash.
	float4 hash_x, hash_y;
	FAST32_hash_2D(Pi, hash_x, hash_y);

	//	calculate the gradient results
	float4 grad_x = hash_x - 0.49999;
	float4 grad_y = hash_y - 0.49999;
	float4 grad_results = rsqrt(grad_x * grad_x + grad_y * grad_y) * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);

	grad_results *= 1.4142135623730950488016887242097;
	float2 blend = Interpolation_C2(Pf_Pfmin1.xy);
	float2 res0 = lerp(grad_results.xy, grad_results.zw, blend.y);
	return lerp(res0.x, res0.y, blend.x);
}


float displacementSimple(float2 p)
{
	return Perlin2D(p*float2(30.0,50.0));
}

float getClosestDistance(float3 p, float3 dir)
{
	float d = 0.0;
#if D_MAX_STEP_LENGTH_ENABLE
	float minD = 1.0; // restrict max step for better scattering evaluation
#else
	float minD = 10000000.0;
#endif

	float3 objectCenter = unity_ObjectToWorld._14_24_34;
	float3 objectSize = unity_ObjectToWorld._11_22_33*0.5; // + float3(2.0,2.0,2.0);
	//float3 objectCenter = float3(20.0, 15.0, -19.0);
	//float3 objectSize = float3(40.0, 4.0, 40.0)*0.5; // +float3(2.0, 2.0, 2.0);

	float3 dp = sign(dir)*(p - objectCenter);
	float3 dists = max(float3(0.0, 0.0, 0.0), objectSize - dp);
	return min(min(minD, dists.x), min(dists.y, dists.z));
}


float3 evaluateLight1(float3 pos)
{
	float3 L = _FogLight1Pos - pos;
	return _FogLight1Color.xyz * _FogLight1Factor / dot(L, L);
}

float3 evaluateLight2(float3 pos)
{
	float3 L = _FogLight2Pos - pos;
	return _FogLight2Color.xyz * _FogLight2Factor / dot(L, L);
}

// To simplify: wavelength independent scattering and extinction
float getParticipatingMedia(out float muS, out float muE, in float3 pos)
{
	float3 dp = (pos - unity_ObjectToWorld._14_24_34);
	//muS = 0; muE = 0; return 0;
	float noise = clamp(displacementSimple(pos.xz*_FogNoiseScale + _Time.x*_FogNoiseSpeed), 0.0, 1.0);
	float heightFog = _FogHeight + _FogNoiseHeight * noise;
	heightFog = 0.3*clamp(heightFog - abs(dp.y), 0.0, 1.0);

	const float fogFactor = _FogFactor;

	const float sphereRadius = unity_ObjectToWorld._11*0.65 + (noise-1)*0.5;
	float sphereFog = clamp((sphereRadius - length(dp))*5.0 / sphereRadius, 0.0, 1.0);

	const float constantFog = 0.0;

	muS = constantFog + heightFog*fogFactor*sphereFog;

	const float muA = 0.0;
	muE = max(0.000000001, muA + muS); // to avoid division by zero extinction
	return muS;
}

#define phaseFunction (1.0 / (4.0*3.14))

float volumetricShadow(in float3 from, in float3 to)
{
#if D_VOLUME_SHADOW_ENABLE
	const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing
	float shadow = 1.0;
	float muS = 0.0;
	float muE = 0.0;
	float dd = length(to - from) / numStep;
	for (float s = 0.5; s<(numStep - 0.1); s += 1.0)// start at 0.5 to sample at center of integral part
	{
		float3 pos = from + (to - from)*(s / (numStep));
		getParticipatingMedia(muS, muE, pos);
		shadow *= exp(-muE * dd);
	}
	return shadow;
#else
	return 1.0;
#endif
}

void traceScene(float3 rO, float3 rD, inout float3 finalPos,
	inout float4 scatTrans)
{
	const int numIter = 100;

	float muS = 0.0;
	float muE = 0.0;

	float3 light1Pos = _FogLight1Pos;
	float3 light2Pos = _FogLight2Pos;

	// Initialise volumetric scattering integration (to view)
	float transmittance = 1.0;
	float3 scatteredLight = float3(0.0, 0.0, 0.0);

	float d = 0.0;
	float3 p = float3(0.0, 0.0, 0.0);
	float dd = 0.0;
	for (int i = 0; i<numIter; ++i)
	{
		float3 p = rO + d*rD;

		getParticipatingMedia(muS, muE, p);


#if D_USE_IMPROVE_INTEGRATION
		{
			// See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/
			float3 S = evaluateLight1(p) * (muS * phaseFunction * volumetricShadow(p, light1Pos));// incoming light
			S += evaluateLight2(p) * (muS * phaseFunction * volumetricShadow(p, light2Pos));// incoming light
			float3 Sint = (S - S * exp(-muE * dd)) / muE; // integrate along the current step segment
			scatteredLight += transmittance * Sint; // accumulate and also take into account the transmittance from previous steps

													// Evaluate transmittance to view independentely
			transmittance *= exp(-muE * dd);
		}
#else
		{
			// Basic scatering/transmittance integration
#if D_UPDATE_TRANS_FIRST
			transmittance *= exp(-muE * dd);
#endif
			scatteredLight += muS * evaluateLight(p) * phaseFunction() * volumetricShadow(p, lightPos) * transmittance * dd;
#if !D_UPDATE_TRANS_FIRST
			transmittance *= exp(-muE * dd);
#endif
		}
#endif


		dd = getClosestDistance(p, rD);
		if (dd<0.001)
			break; // give back a lot of performance without too much visual loss
		d += dd;
	}

	finalPos = rO + d*rD;

	scatTrans = float4(scatteredLight, transmittance);
}

			fixed4 frag (v2f i) : SV_Target
			{
				fixed4 col = _Color;
				// sample the texture
				//return tex2D(_MainTex, i.uv);
				float3 camPos = _WorldSpaceCameraPos.xyz;

				float3 rO = i.worldPos;
				float3 rD = normalize(i.worldPos - camPos);
				//rO *= 1.0;
				float3 finalPos = rO;
				float3 albedo = float3(0.0, 0.0, 0.0);
				float4 scatTrans = float4(0.0, 0.0, 0.0, 0.0);
				
				traceScene(
					rO, rD, finalPos, scatTrans);


				//lighting
				//float3 color = (albedo / 3.14); // *evaluateLight(finalPos, normal) * volumetricShadow(finalPos, LPOS);
				// Apply scattering/transmittance
				//color = color * scatTrans.w + scatTrans.xyz;
				col.xyz *= scatTrans.xyz;
				col.w = scatTrans.w;

				// Gamma correction
				float g = 1.0 / 2.2;
				col.xyz = pow(col, float3(g,g,g)); // simple linear to gamma, exposure of 1.0
				/*
				float muS;
				float muE;
				col.z = getParticipatingMedia(muS, muE, rO);
				//col.a = muS;
				col.x = muS;
				col.y = muE;
				col.x = getClosestDistance(rO, rD);
				//col.xyz = getSceneColor(rO, material); // rO.xyz;
				*/
				return col;
			}
			ENDCG
		}
	}
}
